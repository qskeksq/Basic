7. 인터페이스의 이해

### 1.1 핵심
- 1. 언제 사용하는가 2. 다형성 3. 사용법
- 인터페이스의 핵심은 추상 메소드와 비교하여 아는 것이다. 인터페이스는 속성값을 가질 수 없고, 메소드 블록에 코딩을 할 수 없다. 오직 메소드(기능)만을 강요할 수 있다. 추상 클래스와 인터페이스는 설계 도구이다.
- 인터페이스를 통한 다형성의 구현 : setOnClickListener(this)가 바로 인터페이스를 통한 다형성 구현이다.
- implements View.OnClickListener-onClick
- 인터페이스를 통한 설계 : Bbs

- 인터페이스는 기능의 모음이다. 즉, 메소드를 모아놓은 곳이다
- 인터페이스는 객체로 만들 수 없고 상속해서만 쓸 수 있다
- 결국, 추상 메소드와 함께 설계를 위한 하나의 도구이다.

### 1.2 인터페이스의 역할
- 객체의 사용 방법을 정의한 타입
- OnClickListener를 사용하는데 객체의 구조를 알아야 한다면 매우 불편할 것이다. 하지만 나는 리스너 인터페이스에 onClick이라는 메소드가 있는 것만 알면 된다.
- 리스너를 보면 알 수 있듯이 인터페이스는 여러 객체에서 사용한다. 그리고 사용할 때마다 정의하는 메소드 블록이 다르다는 것을 알 수 있다.
- 인터페이스와 추상 클래스는 생성자가 없다. 왜냐하면 객체를 생성할 수 없기 때문이다.
- 클래스 간의 관계로 따지자면 사용 방법이 동일한 클래스를 만드는 기술이군

### 1.3 인터페이스 선언(사용하는법)
- public interface 인터페이스명{       }
- 인터페이스의 모든 메소드는 public이다. 가져다 쓰라고 만들어 놓았으니까.
- 상수 : 인터페이스는 속성 값, 데이터 값을 저장할 수는 없는데 상수는 선언할 수 있다. 반드시 초기값을 지정해 주어야 한다. public static final을 써 주지 않으면 자동으로 상수로 바뀐다. 상수이기 때문에 대문자로 써 주어야 한다. 설계할 때 필요한 구체적인 값들을 미리 상수로 설정해 두는 것이다.
- 인터페이스의 모든 메소드는 public 제한자를 갖는다.
- 추상 메소드 : 실제 실행부(구현부)는 인터페이스 구현 객체에 있다. 인터페이스의 메소드는 추상 메소드로 abstract를 생략한 것일 뿐 추상 클래스의 추상 메소드와 동일하다.
- 디폴트 메소드 : 메소드 블록이 있는 메소드로 default 키워드가 붙는다. 어떤 차이가 있는지모르겠다.
- 정적 메소드 : 정적 메소드와 동일하다. 메소드 블록도 있고 static 키워드도 붙는다.

### 1.4 인터페이스 구현
- implements 인터페이스명
- 구현 객체에서 인터페이스의 추상 메소드를 정의해준다. 추상 메소드를 오버라이드 하지 않으면 추상 클래스로 변형된다.

### 1.5 추상 클래스와의 비교
- 추상 클래스는 ‘클래스’인데 메소드를 강제화 할 수 있고(인터페이스의 기능), 메소드 블록 안에 코딩이 가능하며, 클래스에 속성, 데이터를 정의할 수 있다.
- 인터페이스는 속성을 저장할 수 없고, 메소드 블록에 코딩을 할 수 없으며, 오직 메소드를 강제하는 기능밖에 없다. 여기서 인터페이스를 언제 사용할지 알 수 있는데, 속성이 있는 경우에는 인터페이스가 될 수 없다. 다만 정해진 수, 상수는 가능하다.
- 실제 사용 : 추상 클래스와 인터페이스를 많이 사용해 보는 방법밖에 없다.

### 2.1 인터페이스의 구현
- 인터페이스는 컴파일시 .class로 컴파일 된다.
- 인터페이스도 참조 타입이다.

### 2.2 익명 인터페이스 구현
- 핵심은 View.OnClickListener listener = new (클래스 이름 implements) View.OnClickListener(){    }
- 설명하자면 클래스 이름 없이 인터페이스를 사용하는 ‘클래스’이다. 하나의 클래스인데 인터페이스를 구현했기 때문에 당연히 인터페이스의 추상 메소드를 {   } 안에 구현해야 한다.
- 한 번 사용하고 말 때 익명 인터페이스를 구현한다. 하지만 비슷한 익명 클래스가 많을 경우는 클래스를 만들어야 하기 때문에 자원이 낭비된다.
- 참고로 OnClickListener를 바로 사용할 수 있는 이유는, View에 있는 인터페이스를 불러왔기 때문이다.

### 2.3 인터페이스 사용(인터페이스를 실전에서 어떻게 사용하는가-다형성의 이해)
- class Television implements RemoteControl
- class Radio implements RemoteControl 일 때
- RemoteControl rc = new Television()
- RemoteControl rc = new Radio() 가 가능하다
- 다형성 구현의 핵심인 오버라이드가 자동으로 적용된다. 왜냐하면 추상 메소드는 반드시 오버라이드 해야 하기 때문이다.
- MyClass 의 생성자 MyClass(RemotrControl rc)의 인수에 두 객체가 들어갈 수 있다.
- 당연히 메소드 인자에도 똑같이 적용할 수 있다.
- Television, Radio는 구현 객체이고, 이를 이용해서 개발 코드를 작성한다. 이 때 인터페이스가 타입으로 사용될 수 있는 것을 뜻한다.
- 이것이 자바다 359쪽 참조

### 3.1 인터페이스를 통한 설계의 이해

![인터페이스1](https://github.com/qskeksq/Basics_for_java_programming/blob/master/pic/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4.png?raw=true)

![인터페이스2](https://github.com/qskeksq/Basics_for_java_programming/blob/master/pic/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A42.png?raw=true)

![구조의 이해](https://raw.githubusercontent.com/qskeksq/Basics_for_java_programming/master/pic/%EA%B5%AC%EC%A1%B0%EC%9D%98%EC%9D%B4%ED%95%B4.bmp)

- 실제 설계 할 때 어떤 경우 인터페이스, 추상 클래스, 일반 클래스를 쓰는지 잘 이해할 필요가 있다.
- 어떠한 속성이 있는 경우면 일단 인터페이스는 안 된다. 이 속성들이 공통 속성이거나 거의 바꿔서 쓰지 않을 경우 추상 클래스로, 특정한 속성을 가진다면 일반 클래스로 정의하자
- 설계할 때는 카테고리화 해야 한다. 공통 속성을 가진 변수를 상위 카테고리로 정하는 것이 좋다. 사람(의사, 간호사, 선생님...), 빌딩(경찰서, 병원...), 인프라(...)


### 4.1 인터페이스를 통한 다형성 구현
- 다형성은 상속으로부터 온다. 인터페이스도 비슷하게 사용할 수 있다.
- 다형성의 핵심은 ArrayList<Father>
- 인터페이스를 통한 다형성 구현의 핵심은 setOnClickListener(this)
- 마치 상속 했을 경우 그 상속받은 객체 타입으로 형 변환해서 다형성을 구현할 수 있듯이 인터페이스도 어떻게 보면 상속 받는 것이고, 그래서 그 타입으로 형 변환해서 사용할 수 있다
- 그리고 인터페이스는 여러 곳에서 여러 개를 구현할 수 있기 때문에 상속보다 다형성 구현에 더 유동적이고 자유롭다
- 인터페이스를 구현한 여러 클래스를 마음 것 바꿔 쓸 수 있는 것이 핵심. RemoteControl을 구현했다면 Television, Radio, Aircondition 모두 갖다 사용할 수 있는 것이다. 혹은 Television1, Television2로 서로 성능 비교, 버그 검사를 할 수 있다.

#### 4.2 상속과 인터페이스의 이해
- 상속 : 하위 클래스 만드는 기술
- 인터페이스 : 사용 방법이 동일한 클래스를 만드는 기술
- 공통점 : 다형성 구현하는 기술

#### 4.3 필드의 다형성
- 상속 : 자식 객체를 대입해서 교체
- 인터페이스 : 구현 객체를 대입해서 교체

#### 4.4 매개변수의 다형성
- interface Vehicle();
- Bus implements Vehicle
- Car Implements Vehicle
- 메소드(Vehicle vehicle)에 Bus, Car 들어갈 수 있음.

#### 4.5 배열로 구현 객체 관리
- 인터페이스를 구현한 객체들을 배열에 담아서 사용하는 것. ArrayList<RemoteControl>
- 당연히 다형성의 핵심은 오버라이드이기 때문에 같은 메소드, 다른 값을 출력할 수 있다.

#### 4.6 강제 타입 변환
- 인터페이스에 3개, 구현 객체에 5개 클래스가 있을 때 형 변환을 하면 인터페이스의 3개 밖에 못 쓰기 때문에 강제 형 변환을 해 줄 수 있다.


### 5.1 다중 인터페이스와 상속
-인터페이스는 여러개를 구현 가능하다. implements A, B, C;
-인터페이스는 서로 상속이 가능하다. 다만 상속받는 부모의 추상 메소드 또한 구현해 줘야 한다.

### 6.1 인터페이스의 확장(디폴트 메소드)
- 디폴트 메소드를 사용하는 이유 : 처음 설계한 내용에 메소드를 추가해야 하는데, 이미 이 인터페이스를 구현한 클래스가 여러개라면, 이 클래스들에 모두 메소드를 정의해 줘야 한다. 디폴드 메소드는 추상 메소드가 아니라서 원하는 곳에만 넣어줄 수 있다. 또한 메소드 블록이 있으며, 원한다면 재정의 할 수 있다.
- 디폴트 메소드가 있는 인터페이를 상속받는 경우 1. 상속 2. 오버라이드 3. 추상 메소드로 변화 시킬 수 있다.
추상 메소드로 바꾸는 방법은 default를 빼고 메소드 블록을 없애면 된다.
