# 5. 클래스의 이해

## (1) 객체 지향의 이해

- 객체 지향이 무슨 의미인가?
- 객체를 왜 만드는가? Crime 객체를 만드는 이유를 생각해 보면 알 수 있다. 항상 중요한 것은 데이터를 어떻게 처리할 것인가!!
- Object, class, instance를 몽땅 객체로 뭉뚱그려 쓰는데 읽고 쓸 때 구분해서 알아들어야 한다.
- 클래스에 대한 이해, 원론적이기만 객체 지향을 이해하는 것이 중요한 이유는, 스스로 코딩을 짤 줄 알아야 하기 때문이다. 문제만 풀고 시키는 것만 하려면 몰라도 되겠지만, 내가 원하는 앱을 만들려면 처음부터 끝까지 하나도 모호한 것이 있어서는 안 되고, 그 중 가장 중요한 것이 구조와 틀을 짜는 것인데 클래스가 바로 그 구조와 틀이다. 이 클래스는 어디에 두고, 어떤 역할이고, 누가 사용할 수 있고, 어떤 데이터를 다루는 클래스인가. 이런 것들을 잘 알아야 자유로운 코딩을 할 수 있다.

### object&class&instance의 이해
- object 객체는 하면 코드를 가지기 전 단계 하나의 사물, 물질을 뜻한다. 컴퓨터, 책상, 사람과 같이
- class 클래스라 하면 이 객체를 코드로 바꾼 것을 클래스라 하고
- instance 인스턴스는 클래스가 new를 통해 메모리에 올라갔을 때 인스턴스라 한다. 즉, 메모리가 올라갈 때 내가 선언한 ‘멤버 변수’만큼이 메모리가 올라가는데, 이것을 인스턴스라 한다.
- 참고로 코드 전체는 메소드 에리어에 올라감.
- 그렇다면 객체지향은 여기서 어떤 것을 말하는 것인가? Object지향을 뜻한다. 설계지향언어이기 때문이다.

### 객체 지향의 특징(장점이자 내가 잘 해야 하는 것)
- 1. 캡슐화 : 접근 제한자를 통해 노출할 변수와 보호할 변수를 결정할 수 있다. 마치 tv의 대부분은 가려져 있고 전원, 음량 버튼은 바깥으로 나와 있는 것처럼
- 2. 상속 : 1. 코드 중복 피하기(개발 용의) 2. 유지보수 3. 다형성
- 3. 다형성 :  1. 상속 2. 인터페이스를 통해서 다형성을 구현한다. 다형성의 목적은 한마디로 자유롭게 갈아 끼우기 위해서이다. 최적의 선택을 위해 여러개를 만들어 놓고 가장 적합할 때 넣어 쓸 수 있도록 하는 것이 목적이다.

### 메모리에 언제 올라가는지에 대한 이해
- 일단 몇가지 확실한 정보를 알고 가자
- 메소드는 같은 클래스 내에서 이름으로 사용할 수 있다. 다만 메인에서 클래스를 생성한 후 도트 연산자를 써야 하는 이뉴는 main이 static이기 때문이다. static은 static이 아닐 경우 외부 변수나 메소드를 사용할 때 반드시 생성자를 통해 생성해서 사용해야 한다.
- 선언과 초기화로 나눠서 int같은 기본형은 초기화 하지 않으면 클래스 내부에서 갖다 쓸 수 없다. 왜냐하면 메모리에 올라가지 않았기 때문이다. 참조 타입은 생성자를 통해 초기화해서 메모리에 올리지 않으면 오류가 생긴다. 즉, 어찌됬든 메모리에 올라가야 다른 곳에서 갖다 쓸 수 있는 것이다.
- 초기화, new 생성자, static 이 세 가지 경우 메모리에 올라간다. 실행은 바이트 코드로 바꿔 기계에 알려주는 행위이다.

### 객체 간의 관계
- 집합 관계
- 사용 관계
- 상속 관계
- (부품객체+부품객체+부품객체)-->집합객체⌉
- (부품객체+부품객체+부품객체)-->집합객체-->집합 객체
- (부품객체+부품객체+부품객체)-->집합객체⌋
- 여기서 알 수 있듯이 하나하나의 부품, 부분을 객체로 만들고 또 이것들을 조립해서 하나의 객체로 만들고 결국 만들고자 했던 객체를 만들어 내는 이 설계를 객체 지향 설계라고 하는 것이다. 객체들 간에 서로가 속하는 집합이 될 수도 있고, 단순히 사용하고 버리는 사용 관계가 될 수 있고, 상속해서 합체해 버리는 상속 관계가 될 수 있는데, 이거 나눠서 생각하기 보다는 이 그림에 기반한 객체 지향 설계 설명이 더 좋은 듯 하다



## (2) 클래스 구성

### 클래스 간의 관계
- 일반적으로 클래스는 99개의 라이브러리 클래스와 1개의 메인 실행 클래스로 이루어진다.
- Model View Control 관계

### 클래스의 구성
- 클래스 구성을 이해하기 쉬운 방법은 CriminalIntent의 Crime과 Lab을 생각해 보는 것이다
- 멤버 변수 : 클래스가 존재하는 한 존재한다. 지역 변수는 생성자, 메소드 내에서 쓰고 종료되면 자동 소멸된다.
- 객체 간의 관계와 클래스의 구성
이렇듯 하나의 메인 클래스를 위해 다른 라이브러리 클래스들을 만들며 이 라이브러리 클래스들은 서로 포함하거나 사용하거나 상속해서 코딩을 용의하게 하는 등 관계를 가진다.
- 클래스는 필드 변수, 생성자, 메소드로 이루어진다. 필드 변수는 데이터이다. 데이터를 어떻게 다루는지가 객체 지향의 가장 중요한 일일 것이다. 필드 변수를 클래스 내부에서 쓰려면 반드시 초기화 해야 하며 전격 변수이기 때문에 생성자, 메소드에서 모두 사용할 수 있다. 생성자는 여러 개 생성할 수 있는데, 오버로딩이라고 한다. 그리고 모든 코딩은 메소드에 한다. 왜냐하면 뭔가 일어나는 일은 메소드가 처리하기 때문이다. 클래스 내부의 메소드는 이름을 통해 서로 사용할 수 있다.


### 변수의 이해

### 생성자의 이해-오버로딩
- 오버로딩은 overloading 과적한다는 뜻으로 생성자에 과적함으로 한 개 이상을 싣겠다는 것이다
- 생성자를 원하는 만큼 만들어 두고 필요할 때 골라서 쓰기 위함
Car a = new Car(): <br/>
Car b = new Car(색상);<br/>
Car c = new Car(색상, 모델);

- this를 이용한 생성자 처리
생상자가 많을 경우 this()로 처리할 수 있다.
```
public Car(색상, 모델, 속도, 옵션){
 this.색상 = 색상;
 ...
}
public Car(모델){<br/>
 this(색상, 모델, 속도, 옵션); 해 주고
 this.모델 = 모델
}
```

### 메소드의 이해
- 가장 기초적이고 중요한 것이 메소드는 호출하면 일단 그 안의 기능을 실행한다는 것이다. 그리고 나서 리턴은 리턴대로 따로 쓸 수 있다. 가장 좋은 예가 change = printChange(money, price)일 것이다. printChange는 일단 호출하면 그 안의 기능을 수행한다. 그게 print이든지 뭐든지 하고, 리턴 값은 따로 change를 통해 관리해 줄 수 있는 것이다. 이것을 알면 보다 자유로운 코딩이 가능하다.

- 제어문에서는 return; 이 break 역할 가능하다.
- 인스턴스 변수를 클래스 외부에서 접근할 때는 역시나 객체가 메모리에 로딩되어 있어야 하기 때문에 생성자->참조변수->도트 연산자이다. 하지만 내부에서 접근할 때는 this.변수이름으로 접근하면 된다.
- (전격변수=멤버변수=필드변수=인스턴스변수) != 정적변수. 전격과 정적 다름.

#### 1. 메소드 호출
- 클래스 내부 호출은 위의 printChange처럼 이름을 갖다 쓰면 된다. 외부 호출은 일단 new 생성자로 초기화 시키고, 참조 변수에 도트 연산자를 사용해서 접근한다. 처음에 헷갈리지만 중요한데, 다시 말하면 클래스 내에서는 그냥 이름으로, 클래스 밖에서는 생성자로, 클래스 내부라도 main은 static이기 때문에 생성자로 만들어서 접근해야 한다.

#### 2. 메소드 오버로딩
- 생성자 오버로딩처럼 하나의 메소드 이름에 여러 개를 싣는다는 뜻이다.
- 여러 개 만들어 놓고 가장 적합한 것 골라서 쓴다고 생각하면 좋다. 가장 좋은 예는 System.out.println():은 기본형 byte, char, short, int, long, float, double, boolean 모두 출력 가능한데 이게 메소드 오버로딩이다.



## (3) 클래스의 이해

### static(정적) 멤버의 이해
- 정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드이다. 정적 멤버는 인스턴스에 소속된 멤버가 아니라 클래스에 소속되어 있다.
- 정적 멤버는 객체가 없어도 실행될 수 있다는 점 때문에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다. 객체 자신을 참조하여 this를 사용할 수도 없다. 왜냐하면 객체가 아니기 때문이다. 굳이 사용하고 싶다면 객체를 생성한 후 도트 연산자로 접근하면 된다.
- 사실 이게 이해가 잘 안 가기 때문에 정적 메소드는 인스턴스 필드와 인스턴스 메소드를 바로 사용할 수 없다는 것을 기억하자. 사용하고 싶다면 생성자를 통해 만들고, 참조 변수와 도트 연산자로 접근해서 사용하면 된다. 이 이유 때문에 메인 메소드에서는 같은 클래스 내부일지라도 이름으로 다른 메소드를 갖다 쓸 수 없고, 멤버 변수고 갖다 쓸 수 없다.

#### 1. 기억할 것
- static으로 선언하면 new 하지 않고도 바로 메모리에 로딩된다.
- static을 쓰면 다른 곳에서 클래스 이름을 통해 사용할 수 있다
- 일반 변수와 메소드는 static 메소드에 못 쓰고 new로 생성해서 참조 변수를 통해 사용할 수 있다. 이 이유 때문에 main메소드에는 같은 클래스일지라도 변수나 메소드를 이름으로 갖다 쓰지 못한다.


#### 2. 싱글톤의 이해
- 전체 프로그램에서 단 하나의 객체만 만들어야 하는 경우가 있다. new 연산자를 사용할 수 없고, 새로운 객체를 만들 수 없다는 뜻이다.
- 1. private 생성자 2. private static 클래스 참조변수 = new 클래스 3. static 리턴클래스 getInstance() {   }
- 만드는 방법은 생성자에 private를 붙여서 절대 생성할 수 없게 만든다. 내부적으로 밖에서 꺼내 쓸 수 없는 객체를 한 개 만들고, getInstnace를 통해 단 하나의 객체만을 가져다 쓸 수 있도록 한다. 따라서 그 어느 곳에서든 가져다 쓰는 객체가 같은 것이 생글톤이다.

### final의 이해
- 바꿀 수 없다는 뜻으로 final을 쓰면 이게 최종 값이나 메소드이기 때문에 어디서 바꿀 수 없다.
- 초기화 하는 방법은 두 가지가 있다. 처음 선언할 때 값을 주는 방법, 선언만 해 놓고 생성자에서 초기화 하는 방법이 있다. 두 번째 방법에서 선언만 해 놓고 생성자에서 초기화 하지 않으면 오류가 뜬다. 주민등록번호의 경우 입력 받아야 하고, 바꿔서는 안 되기 때문에 final로 하고 생성자로 외부에서 값을 받아 초기화한다.
- static final : 상수

### 패키지의 이해
- 같은 패키지에 속하는 클래스는 아무런조건 없이 다른 클래스를 이용 가능하다
- 다른 패키지의 경우 import 해야 함
- import를 어디서 하냐면 package에서 한다. 즉, 남이 만들어 놓은 것들 중 편한 것들을 패키지로 만들고 import해서 편하기 쓰는 것이다. 내 프로젝트 안에서 내가 패키지를 만드는 것도 비슷한 이유이다. 원하는 기능이 있는데 여타 메소드와는 조금 기능이 다르다고 하자. sum()인데, 내가 원하는 sum은 전체에서 10%를 반환하는 메소드라 한다면 지금 내 개발 패키지와 섞이지 않게 따로 패키지를 만든 후 import해서 쓰면 된다. 헷갈리지 않아야 할 것이 import해서 써야 한다는 것과 변수와 클래스를 public으로 선언하지 않으면 쓸 수 없다는 것이다.
- 안드로이드에서도 패키지를 어떻게 쓰는가. 각 부위별로 가능한 만큼 세세하게 나눈 후 메인에서 합치는 방식으로 사용한다. 왜냐하면 오류가 생겼을 때 그 곳만 고치면 되기 때문이다.
- package 이름 : com.내 이름.언어명.패키지이름 으로 디폴트를 정한다.


### 접근 제한자의이해
- 클래스는 99개의 라이브러리 클래스와 1개의 메인 실행 클래스로 이루어진다. 라이브러리 클래스는 서로 상속하거나 포함하거나 사용하는 관계로 어떤 관계인지, 누가 내게 접근할 수 있는지 알려줄 필요가 있는데, 이게 접근자이다.
- public : 다른 패키지에서도 사용할 수 있다.
- protected : 패키지 내부에서만 사용할 수 있거나 다른 패키지라도 상속할 경우 사용할 수 있다.
- default : 패키지 내부에서만 사용할 수 있다.
- private : 클래스 내부에서만 사용할 수 있다. 클래스 밖으로 나갈 수 없다.
- 클래스는 3요소보다 강하게 접근자를 적용할 수 없다.


#### 1. 클래스 접근 제한
- 클래스는 무조건 public 아니면 default 둘 중 하나이다.
- default는 같은 패키지 내에서만 사용할 수 있다.
- public은 다른 패키지에서도 아무 제약 없이 사용할 수 있다. 협업할 경우 일단 public으로 만드는 것이 좋다.

#### 2. 생성자 접근 제한
- public, protected, default는 같다
- priavte의 경우 생성자에 private를 붙이면 싱글톤이라는 뜻이다.

#### 3. 필드와 메소드
- public, protected, default는 같다
- priavte의 경우 클래스 내부에서만 사용하겠다는 의미이다. 객체만의 독특한 데이터의 경우 외부에서 함부로 바꾸면 안 된다. 예를 들어 은행 잔고의 경우 외부에서 바꾸면 안 되기 때문에 private로 작성하고 getter와 setter를 사용해서 처리한다.

### Getter와 Setter의 이해(private와 연동해서 이해하자)
- Crime과 같은 모델을 만들 때에는 외부에서 접근해서 함부로 바꿀 수 없도록 private를 만들고 getter, setter를 통해 원하는 값‘만’을 호출, 변경할 수 있다. 값만이라고 한 이유를 첫 번째 예로 확인하자
- 첫 번째 예 : 자동차 속력의 경우 음수 값이 되어선 안 된다. 따라서 setter 메소드에서 0미만일 경우 접근할 수 없도록 한다.
- 두 번째 예 : 은행 잔고의 경우 함부로 외부에서 접근해서는 안 된다. 따라서 private로 하고 게터와 세터로 접근한다.
