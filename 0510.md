##변수타입, 연산자, 형 변환, 제어문, 클래스, 런타임의 이해

###변수 타입의 이해

- int number = 333 : 이전에는 variable이라 했는데 이제는 identifier 식별자라 부른다.
  메모리에서 333을 찾을 때 'number'라는 식별자로 식별하기 때문이다. String str, Basicsub sub = new BasicSub();도 같은 맥락이다.

- 개발자들은 대부분 변수 타입에서 정수면 int를, 소수면 double을 쓰지만 메모리가 극히 작은 임베디드 프로그램의 경우 예를 들어 100kb의 프로그램의 경우
  소수점을 나타낼 때 double을 쓰면 메모리 낭비가 될 수 있기 때문에 바이트 기준으로 여러 타입이 존재하는 것이다.

- short, int, long, char, double은 기본 타입이고 String은 객체 타입인데 String을 매우 많이 쓰기 때문에 기본형처럼 쓰게 해 준 것이다.

- int int라든가, double double과 같이 변수 타입은 식별자로 못 쓴다.

- 멤버변수, 전역 변수는 클래스 안에서 선언하여 클래스 내 모든 메소드와 생성자에서 갖다 쓸 수 있는 변수이다.
  지역변수는 메소드 안에 선언되어 다른 곳에서 쓸 수 없는 변수를 뜻한다.


###연산자의 이해

- 상수 : final 제어자가 들어간 변수는 상수로 다른 곳에서 변경할 수 없으며 대문자로 쓰는 것이 관례이다.
  final int MID = 5;
  final double PI = 3.14;

- 기본형과 참조형의 차이는 기본형은 크기 제한이 있으나 참조형은 없는 것이다.
  예를 들어 String은 무제한 늘어날 수 있으나 int는 제한이 있는 것을 알 수 있다.

- 논리 연산자를 사용할 때 &&(and and로 둘 다)의 경우 앞에 오는 식 하나가 false이면 뒤 식은 체크하지 않고, ||(or or로 둘 중 하나) 식의 경우
  앞에 오는 식 하나가 true이면 뒤 식은 확인하지 않는다. 즉, 기준이 되는 식이 앞으로 오는 것이 좋으며,
  이런 코드 하나하나가 쌓여서 전체의 속도에 영향을 주는 것이다.

- 3항 연산자를 사용하는 이유는 퍼포먼스가 좋아지는 것이 아니라 코딩의 양이 줄어들어 생산성이 좋아지기 때문이다.
  if(1) {2} else {3}
  System.out.println(1 ? 2 : 3);



###형 변환의 이해

- 문자->int : int a = Integer.parseInt(문자열);
  문자->double : double b = Double.parseDouble(문자열);
  숫자->문자 : String c = String.valueOf(숫자);
  숫자->문자 : 숫자 + "";


###조건문(if), 선택문(switch), 순환문(while)의 이해

####**for문**
- for(초기값, 범위, 식) : 여기서 ‘식’에 해당하는 부분이 자유로워야 한다.

- for(int a : 배열값) : 향상된 for문으로 배열값을 a로(a에 넣어서) 하나씩 꺼내 쓴다.

####**switch문**
- switch문은 break가 없고 조건이 맞으면 조건에 맞는 case 모두를 실행시킨다.
  따라서 break가 필요하며 필요에 따라서는 의도적으로 break를 쓰지 않을 수 있다.
  case 35, case 36, case 37, case 38에서 case 36에서 실행되고 break가 없으면 이하의 모든 case가 다 맞도록 실행된다.
  이를 의도적으로 이용해 case 38에 ‘36보다 큰 수를 나타내자’고 표현한다면 case 38에서만 break가 있으면 된다.


###object&class&instance의 이해

- object 즉, 객체라 하면 컴퓨터, 책상, 동물과 같이 코드를 가지기 전 단계 하나의 사물, 물질을 뜻한다.

- class 클래스라 하면 Object 객체를 코드로 바꾼 것이다.

- instance 인스턴스는 클래스가 new를 통해 메모리에 올라갔을 때 인스턴스라 한다.
  즉, 실행될 때 선언한 ‘멤버 변수’만큼이 메모리에 올라가는데, 이것을 인스턴스라 한다.(참고로 코드 전체는 메소드 에리어에 올라간다)

- 객체지향에서 객체는 Object를 뜻하는데, 자바는 설계 지향 언어이기 때문이다.


###Runtime의 이해

- 가장 하위에 하드웨어가 있고, 그 위에 운영체제인 os가 들어온다. 자바의 강점은 각 os에게 jvm이라는 가상 실행 머신을 제공한다는 점이다.
  자바코드를 작성한 후 컴파일을 하면 바이트 코드로 만들어 지는데, 이 바이트 코드가 각 운영체제별로 다시 작성될 필요 없이 os에서 jvm만 설치해 주면
  바이트 코드를 사용할 수 있는 것이다.

- 과정 : 처음 java 코드를 작성하고 컴파일러 javac.exe로 컴파일 하면 바이트 코드가 된다. 여기서 실행하면 java.exe가 실행되어 바이트 코드를
  기계어로 바꾸고, 운영체제와 하드웨어에게 전달된 후에는 main 메소드를 찾아 실행한다.

- JRE 는 실행머신인 jvm과 여러 API를 모아놓은 집합으로 주로 실행하기 위해 설치하고,
  JDK 는 JRE와 여러 개발도구를 모아 놓은 집합이다. 즉, 이 둘을 설치함으로써 자바를 개발하고 실행할 수 있게 된 것이다.
  참고로 JVM 안에 있는 내부 컴파일러에는 JIT와 AOT가 있다. 이전에는 둘이 구분했으나 안드로이드 7.0 누가부터는 둘을 나누어 알맞은 때에 사용한다.
