# 6. 상속의 이해

## (1)기본 이해

- 제어자가 private인 경우는 상속할 수 없다.
- 패키지가 다른 경우 defualt, private는 상속할 수 없다.
- 상속한 경우 그 클래스에 그대로 쓰여 있다고 생각하자!!
- 영어를 해석해도 그렇고 메모리에서 적용되는 것을 봐도 자바에서 상속은 확장이라는 표현이 더 맞는 듯 하다. 메모리에서 생성될 때 부모 객체에 자식 객체를 더해 하나의 자식 객체를 만드는 방식으로, 부모 객체에서 확장되는 방식이다.

### 원리
- 객체를 사용하기 위해서는 메모리에 올라와 있어야 한다. 상속하는 경우 먼저 부모 객체를 생성하고 그 다음 자식 객체를 생성한다.

### 상속의 목적
1. 개발 용의 : 상속한 경우 코드를 추가해 주기만 하면 된다.
2. 유지보수가 쉬워짐 : 부모 클래스를 고치면 자식 클래스도 모두 고쳐진다.
3. 다형성 구현 : 하나의 타입에 여러 가지를 갖다 쓸 수 있다. 즉, 하나 타입으로 해 놓고, 원하는 것 여러 개 구현해 놓은 후, 가장 적합한 것을 골라 쓸 수 있다.

### 생성자
- 부모 객체에 명시적 생성자가 없을 경우, 자식 객체 생성자를 사용하지 않을 때에 자동으로 자식 객체 생성자에 super()이 생긴다. 만약 자식 객체에서 생성자를 사용한다면 반드시 super()을 써줘야 한다. super()이 바로 부모 객체를 생성하는 생성자이다. 위에서 써 놓은 원리에서 부모 객체를 먼저 생성하고 자식 객체를 생성한다는 뜻도 super()이 먼저 생성되고 그 다음 자식 객체 생성자가 들어간다는 뜻이다.

### super()의 이해
- this는 현재 속해 있는 클래스 전체를 리턴한다. 따라서 도트 연산자를 통해 그 클래스에 있는 모든 멤버 변수를 사용할 수 있었던 것이다. super도 이와 유사하게 부모 객체 전체를 리턴한다. 따라서 도트 연산자를 통해 부모 객체에 있는 모든 멤버를 가져다 쓸 수 있고, 생성자로도 쓰이는 것이다.


### final의 추가적인 이해
- final class : 상속할 수 없다. 부모가 될 수 없다. 마지막 자식이다.
- final 메소드 : 재정의 할 수 없다. 그대로 써야 한다.

### protected 접근자
- protected 생성자 : 상속할 수 있다는 뜻
- protected 메소드 : 상속할 때 자기 것처럼 쓰거나 오버라이드 할 수 있다.
- protected 변수, 필드 : 상속할 때 자기 것처럼 쓸 수 있다.

## (2)오버라이딩

- 오버로딩이랑 헷갈리지 말자
- 사실 오버라이드는 메소드와 변수 모두 재정의 하는 것인데 주로 메소드를 칭한다.
- 부모에게 있는 메소드를 재정의해서 사용하는 것을 뜻한다. 즉, 그냥 가져다 쓸 수도 있고, 원하면 고쳐서 쓸 수 있다는 것이다. 오버라이드 하면 호출될 때 오버라이드 된 메소드가 호출된다.
- 조건
 1. 리턴타입, 이름, 인자가 같아야 한다.
 2. 강한 제어문 쓸 수 없다.
 3. 예외처리 할 수 없다.
- 만약 오버라이드 했는데 다시 부모 메소드를 ‘호출’하고 싶은 경우 ‘super.메소드이름’을 호출하면 된다. 예를 들어 if( ... ) {오버라이드 메소드} else { super.메소드 };
- final 메소드는 재정의 할 수 없다.
- private 멤버(변수, 메소드)는 재정의 할 수 없다. 값, 메소드 모두 재정의 불가.

#### 오버라이드를 통한 설계
- 오버라이드 메소드 기능이 10개라고 해보자. 내가 1개만 오버라이드 하고 싶다면 나머지 9개를 따로 process();라는 메소드에 빼서 사용할 수 있다. 그렇게 하면 상속으로 process()도 사용할 수 있고, 나머지 한 줄도 오버라이드 해서 바꿀 수 있다.

## (3)다형성

### 핵심
-일단 이것만 기억하자. 다형성의 핵심은 ArrayList'<'Father'>' 이다.

### 다형성의 이해
- 정의 : 동일한 타입 but 다양한 결과 <br/>
Mouse m = new WheelMouse(); <br/>
Mouse m2 = new LightMouse(); <br/>
Mouse m3 = new NoLineMouse();
- 마치 기본타입의 형 변환처럼 상위 타입에는 그냥 넣어서 쓸 수 있다. 자동 타입 변환이 가능하다는 뜻
- 사용법  : 상속 --> 오버라이드 --> 타입 변환
- 만약 자동 형 변환하면 부모 필드와 메소드만 사용할 수 있다. 하지만 기억할 것은 상속을 통한 다형성이 있기 때문에 오버라이드 하면 원하는 메소드를 사용할 수 있다. 사실 다형성에서의 오버라이딩이 다형성의 핵심이다. 왜냐하면 여러 결과를 나타내기 위해서는 오버라이드 된 메소드를 사용해야하기 때문이다.
- 다형성의 장점 : 필요에 따라 최적의 결과를 내는 객체를 골라서 사용할 수 있다는 뜻이다.

### 타입 변환
 1. 자동 타입 변환
 2. 강제 타입 변환 : 자식 타입의 멤버(필드, 메소드)를 다시 쓰고 싶을 때 사용한다.
- 사용법 : 자동타입변환 --> instanceof --> 강제타입 변환
- 왜 사용하는가? 자동 타입 변환하면 부모의 필드와 메소드만 쓸 수 있기 때문이다.
- 객체 타입 하는 방법 : 타입변환 전에 확인하는 작업이 필요한데 instanceof를 사용한다
boolean check = parent instnaceof Child

## (4)추상 클래스

### 핵심
- 일단 이것만 기억하자. 추상 클래스는 객체를 만들지 않고 오직 상속으로만 사용하며, 이 말은 자식에게 물려줄 공통 속성만을 가지고 만든 클래스라는 뜻이다. 클래스인데 상속으로만 사용하며, 오버라이드를 강제할 수 있다. 인터페이스와 비교하여 속성을 가질 수 있고, 메소드에 코딩을 할 수 있으며, 추상 메소드가 있다.

### 추상 클래스
- 정의 : 절대 객체를 생성해서 쓰지 않는 클래스이다. 너구리, 삼양라면 등 구체적인 라면은 있지만 실제 ‘라면’이라는 라면은 없다. 즉, 공통된 특성을 뽑아서 만든 것이 추상 클래스이다. 목적 자체가 공통된 특성을 뽑아서 만든 것이기 때문에 상속으로만 쓰이고 절대 객체를 생성하지 않는다.
- 용도
 1. 이름 통일 : 기본 특성들의 이름이 다르면 안 될 것이다. 따라서 추상 클래스로 멤버(필드, 메소드)를 통일한다.
 2. 클래스 작성 시간 절약 : 미리 기본 특성을 만들어 놓기 때문이다
즉, 추상클래스를 만들어서 “이거 이 이름으로 이렇게 만들어!”하고 지시하는 것이다.
타이어 규격을 예로 들 수 있다. 자동차 타이어는 만드는 사람이 규격을 만들어 놓고 마음대로 갈아 끼울 수 있는데, 그 공통된 특성을 모아놓은 것이 타이어 추상 클래스라 할 것이다.
 3. 기능적인 용도 : 인터페이스와 비교하여 기능을 강제할 수 있고, 메소드에 코딩이 들어갈 수 있고, 속성을 저장할 수 있다. 즉, 클래스인데, 기능을 강제할 수 있는 클래스이고, 객체를 만들지 않고 오직 상속으로만 쓰이는 클래스

#### 추상 클래스 생성자
- super()로 똑같다. 왜냐하면 부모 객체로만 쓰이기 때문이다.

#### 추상 메소드=오버라이딩 강제화
- 추상 클래스는 메소드 오버라이딩을 강요할 수 있는데, abstract 메소드로 강제화 할 수 있다
- 오버라이딩은 결국 다형성의 일환임을 꼭 기억하자!
- 추상 클래스의 메소드 의미
 1. 미리 만들어 놓았으니 그냥 써도 된다 : 타이어 추상 클래스 굴러가기 기능
 2. 추상 클래스 : 이거 반드시 재정의 해야 한다. : 동물 추상 클래스라면 울음소리가 다 다르다
-추상 메소드는 선언부만 있고 정의 블록이 없음 {  }가 없음.
