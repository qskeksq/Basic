
## 패키지, 컴파일, 제한자, 생성자, Collection, String

###package사용의 이해
- import는 package에서 한다. 즉, 남이 만들어 놓은 것들 중 쓰기 편한 것들을 패키지 안에 두고 import해서 코딩에 편의를 두는 것이다.
  프로젝트 안에서 내가 패키지를 만드는 것도 비슷한 이유이다. 원하는 기능이 있는데 여타 메소드와는 조금 기능이 다르다고 하자. sum()을 예로 들자면
  원하는 sum()이 전체에서 10%를 반환하는 메소드라 한다면 현 개발 패키지와 섞이지 않게 따로 패키지를 만든 후 import해서 쓰면 된다.
  헷갈리지 않아야 할 것이 내가 만들었더라도 다른 패키지이면 import해서 써야 한다는 것과 변수와 클래스를 public으로 선언하지 않으면 쓸 수 없다는 것이다.
- package 이름 : com.사용자이름.언어명.패키지이름를 디폴트로 정한다
- private, default 지역 제한자는 패키지나 클래스에 상관 없이 절대 접근을 할 수 없다.

###컴파일의 이해
- 먼저 선언과 초기화를 구분한다.
- int[] arr = new int[숫자];를 실행하여 메모리에 올리면 arr은 **자동으로** 0으로 초기화 된다.
  하지만 ArraySub[] sub = new ArraySub[10];을 실행하여 메모리에 올라가면 nullpointerexeception 에러가 뜬다.
  왜냐하면 위의 식은 마치 Arraysub sub[0]...;과 같은 상태이기 때문이다. 즉, 가리키는 게 없이 공간만 할당 받았기 때문에 java메모리 안에 있는 null을
  가리키는 것이다.(null이라 함은 sub가 아무것도 가리키고 있지 않다는 것을 알려주기 위해 전체 메모리에 1개 있는 가상의 존재).
  즉 ArraySub sub = new ArraySub(); 상태가 되어 생성자를 통해 생성을 해 줘야 가리키는 게 있다.


###접근 제한자의 이해
- private, default 지역 제한자가 있는 클래스는 패키지나 클래스에 상관 없이 접근을 할 수 없다.
- 클래스는 자체가 static이기 때문에 클래스는 static이 없고, 메소드와 변수만 static이 있다.


###생성자의 이해
- new Car();에서 Car()는 클래스가 아니라 생성자이다.
- 전역변수의 초기화는 주로 생성자에서한다.
- 생성자를 쓰지 않아도 자동으로 생성자를 만들어 주는데, Car()를 예로 들 수 있다.
- Car car = new Car();는 생성하는 만큼 메모리에 올라간다. 식별자가 다른 객체로 메모리에 올라간다.
cf)생성자와 static의 비교


###Collection의 이해
- 컬렉션은 동적 객체 배열이라고 한다.
  동적이라는 것은 개수가 정해지지 않았다는 것이며, 객체 배열은 기본형이 아닌 객체를 배열에 담는다는 것을 뜻한다.
- 반드시 제네릭과 같이 쓴다. 제네릭과 같이 쓰지 않으면 여러 타입의 객체가 섞여 타입으로부터 얻을 수 있는 메소드를 쓸 수 없다.

#### 1.List형
- 제네릭을 사용하지 않는 경우 .add하는 순간 모든 객체들이 Object 타입으로 바뀌어 Object 클래스의 속성만 사용할 수 있다.
  예를 들어 Integer값으로 넣으면 Object클래스로 변환된다. 하지만 대부분의 경우 여러 타입을 한꺼번에 배열하는 경우는 없기 때문에 제네릭으로 타입을 지정한다.
- 내부적으로 값이 입력되면 값과 함께 순서(인덱스)가 부여된다.
- <>를 통해 타입을 명시해준다.
- ArrayList<타입> list = new ArrayList<>();
- 메소드 :　list.add/list.get/list.size/add는 순서를 따로 정할 수 있다. add(순서, 값)

#### 2 Map형
- 내부적으로 값이 입력되면 순서(인덱스)가 부여되지 않고 키 값을 같이 넣어줘서 구분한다.
- HashMap<키 타입, 값 타임> map = new HashMap();
- 메소드 : map.put(키, 값)/map.get(키)/map.size
- 개인정보 조회하는 경우 대응되는 값으로 찾기 때문에 Map을 사용한다.

#### 3.Set형
- list와 사용방식이 매우 유사하지만 반복된 값을 허락하지 않는다.
- 주민등록번호와 같이 반복되는 값이 없어야 하는 경우 사용한다.


### String의 이해
String name = "안녕하세요“;
- String str = name.subString(시작지점, 자를 지점) : 원하는 글자를 잘라내 리턴
- int length = name.length() : 글자 개수 리턴
- char chr = name.charAt(인덱스) : 리턴 타임이 char인 것으로, 원하는 한 글자 리턴
- int ind = name.indexOf("하세“) : 몇 번째 글자인지 자리를 리턴
- String[] chunk = name.split("하“) : ""값을 기준으로 앞 뒤를 각각 배열에 넣어 리턴
 String str = name.replace("하“, "라라라라랄”) : 앞 글자를 뒤 글자로 바꿔 전체를 리턴
